      playHoverSound()
    }
  }

  const handleRepresentationTickLeave = () => {
    if (previewMode !== 'hover') return
    setPreviewRepresentation(null)
    setPreviewMode(null)
  }

  const handleFocusCategoryChange = (
    nextCategory: FocusCategory,
    sourceElement?: HTMLElement | null
  ) => {
    if (nextCategory === focusCategory) return
    setFocusCategory(nextCategory)
    runFocusFeedback(nextCategory, sourceElement)
    if (juicyActive && motionSafe && nextCategory !== 'All') {
      const now = performance.now()
      if (now - representationSoundTimestampRef.current > 130) {
        representationSoundTimestampRef.current = now
        playClickSound()
      }
    }
  }

  const handleMeasureChange = (nextMeasure: Measure) => {
    if (measureLocked) return
    if (nextMeasure === measure) return
    setMeasure(nextMeasure)
    setTransitionKey(key => key + 1)
  }

  const handleMarkEnter = (
    event: MouseEvent<SVGElement>,
    country: string,
    category: MeatCategoryKey
  ) => {
    setMarkHoverCategory(category)
    setHoveredDatum({
      country,
      category,
      clientX: event.clientX,
      clientY: event.clientY
    })

    if (!(juicyActive && motionSafe)) return

    const now = performance.now()
    if (now - hoverSoundTimestampRef.current > 130) {
      hoverSoundTimestampRef.current = now
      playHoverSound()
    }
    if (isTransitioning) return
    if (now - sparkleTimestampRef.current > 90) {
      sparkleTimestampRef.current = now
      const color = categoryByKey.get(category)?.color
      emitParticlesFromClient(event.clientX, event.clientY, 8, 'spark', color)
    }
  }

  const handleMarkMove = (event: MouseEvent<SVGElement>) => {
    setHoveredDatum(previous =>
      previous
        ? {
            ...previous,
            clientX: event.clientX,
            clientY: event.clientY
          }
        : previous
    )
  }

  const handleMarkLeave = () => {
    setMarkHoverCategory(null)
    setHoveredDatum(null)
  }

  const handleStageMouseMove = (event: MouseEvent<HTMLDivElement>) => {
    if (hoveredDatum) {
      setHoveredDatum(previous =>
        previous
          ? {
              ...previous,
              clientX: event.clientX,
              clientY: event.clientY
            }
          : previous
      )
    }

    const stage = chartStageRef.current
    if (!stage) return
    const bounds = stage.getBoundingClientRect()
    const x = event.clientX - bounds.left
    const y = event.clientY - bounds.top

    setCursorPosition({ x, y })
    setIsCursorInsideStage(true)
  }

  const handleChartMouseLeave = () => {
    setMarkHoverCategory(null)
    setHoveredDatum(null)
    setIsCursorInsideStage(false)
    if (previewMode === 'hover') {
      setPreviewRepresentation(null)
      setPreviewMode(null)
    }
    wheelAccumulatorRef.current = 0
  }

  const handleCategoryColorChange = (
    category: MeatCategoryKey,
    color: string,
    sourceElement?: HTMLElement | null
  ) => {
    if (sourceElement instanceof HTMLInputElement && activeColorCategory === category) {
      beginColorPickerFrameSession(category, sourceElement)
    }
    setColorPickerFramePosition(previous =>
      previous && activeColorCategory === category ? { ...previous, color } : previous
    )
    setCategoryColors(previous => ({ ...previous, [category]: color }))
  }

  const handleColorSwatchClick = (
    _event: MouseEvent<HTMLButtonElement>,
    category: MeatCategoryKey
  ) => {
    const inputElement = colorInputRefs.current[category]
    if (!inputElement) return
    beginColorPickerFrameSession(category, inputElement)
    inputElement.click()
  }

  const handleColorInputFocus = (
    event: FocusEvent<HTMLInputElement>,
    category: MeatCategoryKey
  ) => {
    beginColorPickerFrameSession(category, event.currentTarget)
  }

  const handleColorInputBlur = () => {
    clearColorPickerFrameSession()
  }

  useEffect(() => {
    tooltipDisplayRef.current = tooltipDisplay
  }, [tooltipDisplay])

  useEffect(() => {
    const media = window.matchMedia('(prefers-reduced-motion: reduce)')
    const update = () => {
      setPrefersReducedMotion(media.matches)
    }

    update()
    if (typeof media.addEventListener === 'function') {
      media.addEventListener('change', update)
      return () => media.removeEventListener('change', update)
    }
    media.addListener(update)
    return () => media.removeListener(update)
  }, [])

  useEffect(() => {
    if (juicyActive) return
    setFocusPulseCategory(null)
    setColorPulseCategory(null)
    setRipple(null)
    setParticles([])
    setGlobalParticles([])
    setChartShakeActive(false)
    setIsCursorInsideStage(false)
    setPreviewRepresentation(null)
    setPreviewMode(null)
    setWheelPendingTarget(null)
    setProjectorFlashActive(false)
    setTransitionRingVisible(false)
    clearColorPickerFrameSession()
  }, [clearColorPickerFrameSession, juicyActive])

  useEffect(() => {
    sliderVisualPercentRef.current = sliderVisualPercent
  }, [sliderVisualPercent])

  useEffect(() => {
    if (!(juicyActive && motionSafe)) {
      sliderVisualPercentRef.current = sliderFillPercent
      setSliderVisualPercent(sliderFillPercent)
      return
    }
    animateSliderVisualTo(sliderFillPercent, SLIDER_VISUAL_DURATION_MS)
  }, [animateSliderVisualTo, juicyActive, motionSafe, sliderFillPercent])

  useEffect(() => {
    if (!(juicyActive && motionSafe)) return
    const handlePointerMove = (event: PointerEvent) => {
      lastPointerClientRef.current = { x: event.clientX, y: event.clientY }
    }
    window.addEventListener('pointermove', handlePointerMove, { passive: true })
    return () => {
      window.removeEventListener('pointermove', handlePointerMove)
    }
  }, [juicyActive, motionSafe])

  useEffect(() => {
    if (!colorPickerFrameVisible || !activeColorCategory) return
    const update = () => {
      const inputElement = colorInputRefs.current[activeColorCategory]
      if (inputElement) {
        const rect = inputElement.getBoundingClientRect()
        colorPickerFrameAnchorRectRef.current = rect
        const nextPosition = computePickerFramePosition(rect, categoryColors[activeColorCategory])
        setColorPickerFramePosition(previous => {
          if (
            previous &&
            Math.abs(previous.x - nextPosition.x) < 0.5 &&
            Math.abs(previous.y - nextPosition.y) < 0.5 &&
            previous.color === nextPosition.color
          ) {
            return previous
          }
          return nextPosition
        })
      }
      colorPickerFrameRafRef.current = window.requestAnimationFrame(update)
    }
    colorPickerFrameRafRef.current = window.requestAnimationFrame(update)
    return () => {
      if (colorPickerFrameRafRef.current !== null) {
        window.cancelAnimationFrame(colorPickerFrameRafRef.current)
        colorPickerFrameRafRef.current = null
      }
    }
  }, [activeColorCategory, categoryColors, colorPickerFrameVisible, computePickerFramePosition])

  useEffect(() => {
    if (!colorPickerFrameVisible) return
    const handleVisibilityChange = () => {
      if (document.hidden) {
        clearColorPickerFrameSession()
      }
    }
    const handleWindowBlur = () => {
      clearColorPickerFrameSession()
    }
    const handlePointerDown = (event: PointerEvent) => {
      const target = event.target as Element | null
      if (target?.closest('.encode-color-editor')) return
      clearColorPickerFrameSession()
    }
    document.addEventListener('visibilitychange', handleVisibilityChange)
    window.addEventListener('blur', handleWindowBlur)
    window.addEventListener('pointerdown', handlePointerDown)
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange)
      window.removeEventListener('blur', handleWindowBlur)
      window.removeEventListener('pointerdown', handlePointerDown)
    }
  }, [clearColorPickerFrameSession, colorPickerFrameVisible])

  useEffect(() => {
    if (!tooltipTarget) return
    if (!(juicyActive && motionSafe)) {
      setTooltipDisplay({
        kg: tooltipTarget.kg,
        percent: tooltipTarget.percent,
        encoded: tooltipTarget.encoded
      })
      return
    }

    const start = tooltipDisplayRef.current
    const target = {
      kg: tooltipTarget.kg,
      percent: tooltipTarget.percent,
      encoded: tooltipTarget.encoded
    }

    const duration = 190
    const ease = d3.easeCubicOut
    let animationFrame = 0
    let startTimestamp: number | null = null

    const step = (timestamp: number) => {
      if (startTimestamp === null) startTimestamp = timestamp
      const t = Math.min(1, (timestamp - startTimestamp) / duration)
      const p = ease(t)
      setTooltipDisplay({
        kg: start.kg + (target.kg - start.kg) * p,
        percent: start.percent + (target.percent - start.percent) * p,
        encoded: start.encoded + (target.encoded - start.encoded) * p
      })
      if (t < 1) {
        animationFrame = window.requestAnimationFrame(step)
      }
    }
