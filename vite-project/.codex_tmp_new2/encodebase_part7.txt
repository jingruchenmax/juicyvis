          .arc<d3.DefaultArcObject>()
          .innerRadius(labelRadius)
          .outerRadius(labelRadius)({
          innerRadius: labelRadius,
          outerRadius: labelRadius,
          startAngle: labelStartAngle,
          endAngle: labelEndAngle,
          padAngle: 0
        }) ?? ''
      countryLabelDefs.push(<path key={labelPathId} id={labelPathId} d={labelPath} fill="none" />)
      if (!ghost) {
        countryRingLabels.push(
          <text key={`donut-country-label-${country.country}`} className="encode-donut-ring-label" dy="0.35em">
            <textPath
              href={`#${labelPathId}`}
              xlinkHref={`#${labelPathId}`}
              startOffset="50%"
              textAnchor="middle"
            >
              {countryLabel}
            </textPath>
          </text>
        )
      }
    })

    return (
      <g className={ghost ? 'encode-chart-layer is-ghost' : 'encode-chart-layer'}>
        <g className="encode-donut-root" transform={`translate(${donutCenterX}, ${donutCenterY})`}>
          <defs>{countryLabelDefs}</defs>
          {arcMarks}
          {countryRingLabels}
          <circle className="encode-donut-hole" cx={0} cy={0} r={innerRadius - 8} />
          <text className="encode-donut-center-title" x={0} y={-8} textAnchor="middle">
            Multi-Ring
          </text>
          <text className="encode-donut-center-subtitle" x={0} y={12} textAnchor="middle">
            Country shares
          </text>
        </g>
      </g>
    )
  }

  const renderSnapshot = (snapshot: ChartSnapshot, ghost: boolean) => {
    if (snapshot.representation === 'stacked-100') {
      return renderStackedBars(snapshot, ghost, 'percent')
    }
    if (snapshot.representation === 'donut') {
      return renderMultiRingDonut(snapshot, ghost)
    }
    if (snapshot.representation === 'heatmap') {
      return renderHeatmap(snapshot, ghost)
    }
    return renderStackedBars(snapshot, ghost, 'kg')
  }

  const ghostSnapshotSignature = ghostSnapshot
    ? `${ghostSnapshot.representation}|${ghostSnapshot.measure}|${ghostSnapshot.focusCategory}|${MEAT_CATEGORIES.map(category => `${category.key}:${ghostSnapshot.colors[category.key]}`).join('|')}`
    : 'none'

  const ghostSnapshotLayer = useMemo(() => {
    if (!ghostSnapshot || !juicyActive) return null
    return renderSnapshot(ghostSnapshot, true)
  }, [ghostSnapshot, ghostSnapshotSignature, juicyActive])

  if (loading) {
    return <div className="encode-loading">Loading Encode data...</div>
  }

  if (error || !dataset) {
    return <div className="encode-error">Encode data error: {error ?? 'Unknown data error.'}</div>
  }

  const tooltipLeft = (tooltipTarget?.clientX ?? 0) + 14
  const tooltipTop = (tooltipTarget?.clientY ?? 0) - 20
  const previewHalfWidth = SVG_WIDTH * 0.5
  const previewScaledWidth = SVG_WIDTH * PREVIEW_SCALE
  const previewLeftX = (previewHalfWidth - previewScaledWidth) * 0.5
  const previewRightX = previewHalfWidth + previewLeftX
  const wheelPreviewActive = previewActive && previewMode === 'wheel'
  const sliderAlignedLeft = `${sliderDisplayPercent}%`
  const currentLayerClass = juicyActive
    ? `encode-current-layer ${
        isTransitioning ? `is-juicy-enter is-juicy-enter-${transitionDirection}` : ''
      }`
    : `encode-current-layer is-basic-fade`

  return (
    <div className={`encode-shell ${juicy ? 'encode-shell-juicy' : 'encode-shell-basic'}`}>
      <div
        className={`encode-chart-shell ${chartShakeActive ? 'is-shaking' : ''} ${
          juicyActive && isTransitioning ? 'is-transition-frame' : ''
        }`}
        ref={chartSurfaceRef}
        onMouseLeave={handleChartMouseLeave}
      >
        <div className="encode-chart-head">
          <h2 className="encode-chart-head-title">
            Per capita meat and fish consumption ({dataset.year})
          </h2>
          <p className="encode-chart-head-subtitle">{chartSubtitle}</p>
          <div className="encode-inline-legend" role="group" aria-label="Category legend">
            {MEAT_CATEGORIES.map(category => {
              const isFocused = focusCategory === category.key
              const isActive = activeHoverCategory === category.key || isFocused
              const displayColor = getCategoryColor(category.key)
              return (
                <button
                  key={category.key}
                  type="button"
                  className={`encode-legend-item ${isFocused ? 'is-focused' : ''} ${
                    isActive ? 'is-active' : ''
                  }`}
                  onMouseEnter={() => setLegendHoverCategory(category.key)}
                  onMouseLeave={() => setLegendHoverCategory(null)}
                  onClick={event =>
                    handleFocusCategoryChange(
                      focusCategory === category.key ? 'All' : category.key,
                      event.currentTarget
                    )
                  }
                >
                  <span className="encode-legend-swatch" style={{ backgroundColor: displayColor }} />
                  <span>{category.label}</span>
                </button>
              )
            })}
          </div>
        </div>

        <div
          className={`encode-chart-stage ${juicyActive && isTransitioning ? 'transitioning' : ''} ${
            wheelPreviewActive ? 'is-wheel-previewing' : ''
          }`}
          ref={chartStageRef}
          onMouseMove={handleStageMouseMove}
          onMouseEnter={event => {
            const stage = event.currentTarget.getBoundingClientRect()
            const x = event.clientX - stage.left
            const y = event.clientY - stage.top
            setCursorPosition({ x, y })
            setIsCursorInsideStage(true)
          }}
          onMouseLeave={() => {
            setIsCursorInsideStage(false)
            if (previewMode === 'hover') {
              setPreviewRepresentation(null)
              setPreviewMode(null)
            }
          }}
        >
          <svg
            className={`encode-svg ${juicyActive ? 'is-juicy' : 'is-basic'}`}
            viewBox={`0 0 ${SVG_WIDTH} ${SVG_HEIGHT}`}
            role="img"
            aria-label="Per-capita meat and fish consumption by country and category"
          >
            <defs>
              <filter id="encode-hover-glow-filter" x="-40%" y="-40%" width="180%" height="180%">
                <feDropShadow dx="0" dy="0" stdDeviation="2.2" floodColor="#ffffff" floodOpacity="0.9" />
                <feDropShadow dx="0" dy="0" stdDeviation="1.6" floodColor="#1f6feb" floodOpacity="0.65" />
              </filter>
            </defs>

            {ghostSnapshotLayer && (
              <g
                className={`encode-ghost-layer ${isTransitioning ? `is-exit is-exit-${transitionDirection}` : ''}`}
              >
                {ghostSnapshotLayer}
              </g>
            )}

            {!previewActive && (
              <g key={`encode-layer-${transitionKey}`} className={currentLayerClass}>
                {renderSnapshot(currentSnapshot, false)}
              </g>
            )}

            {previewActive && previewSnapshot && (
              <g className="encode-preview-split">
                <g className="encode-preview-left-layer" transform={`translate(${previewLeftX}, 0)`} opacity={0.72}>
                  <g transform={`scale(${PREVIEW_SCALE})`}>{renderSnapshot(currentSnapshot, false)}</g>
                </g>
                <g className="encode-preview-layer" transform={`translate(${previewRightX}, 0)`} opacity={0.52}>
                  <g transform={`scale(${PREVIEW_SCALE})`}>{renderSnapshot(previewSnapshot, true)}</g>
                </g>
              </g>
            )}
          </svg>

          {previewActive && previewRepresentation && (
            <div className="encode-preview-arrow" aria-hidden="true">
              {labelForRepresentation(representation)} -&gt; {labelForRepresentation(previewRepresentation)}
            </div>
          )}

          {juicyActive && transitionRingVisible && isCursorInsideStage && (
            <div className="encode-cursor-layer" aria-hidden="true">
              <svg
                className={`encode-transition-ring ${isTransitioning ? 'is-running' : ''} ${
                  isTransitioning ? '' : 'is-fading'
                }`}
                viewBox="0 0 52 52"
                style={
                  {
                    left: `${cursorPosition.x}px`,
                    top: `${cursorPosition.y}px`,
                    '--encode-ring-c': ringCircumference,
                    '--encode-ring-duration': `${TRANSITION_DURATION_JUICY_MS}ms`
                  } as CSSProperties
                }
              >
                <circle className="encode-transition-ring-fill" cx="26" cy="26" r="11" />
                <circle className="encode-transition-ring-track" cx="26" cy="26" r={ringRadius} />
                <circle
                  className="encode-transition-ring-progress"
                  cx="26"
                  cy="26"
                  r={ringRadius}
                  strokeDasharray={ringCircumference}
                  strokeDashoffset={ringCircumference}
                  transform="rotate(-90 26 26)"
                />
              </svg>
            </div>
          )}
        </div>

        <div
          className={`encode-rep-axis ${juicyActive ? 'is-juicy' : ''}`}
          style={{ '--encode-slider-fill': `${sliderDisplayPercent}%` } as CSSProperties}
        >
          <div className="encode-rep-axis-inner">
            <div className="encode-rep-ticks">
              <div className="encode-rep-ticks-track">
                {REPRESENTATION_OPTIONS.map((option, index) => {
                  const leftPercent =
                    REPRESENTATION_OPTIONS.length > 1
                      ? (index / (REPRESENTATION_OPTIONS.length - 1)) * 100
                      : 0
                  const tickLeft = `${leftPercent}%`
                const isActive = representation === option.value
                const isPreviewTarget = previewActive && previewRepresentation === option.value
                return (
                  <span
                    key={`tick-${option.value}`}
                    className={`encode-rep-tick ${isActive ? 'is-active' : ''} ${
                      isPreviewTarget ? 'is-preview-target' : ''
                    }`}
                    style={{ left: tickLeft }}
                    onMouseEnter={() => handleRepresentationTickEnter(option.value)}
                    onMouseLeave={handleRepresentationTickLeave}
                  >
                    {option.label}
                  </span>
                )
                })}
              </div>
            </div>