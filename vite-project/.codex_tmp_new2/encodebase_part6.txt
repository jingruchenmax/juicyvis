      <g className={ghost ? 'encode-chart-layer is-ghost' : 'encode-chart-layer'}>
        {ticks.map(tick => (
          <line
            key={`grid-${mode}-${tick}`}
            className="encode-grid-line"
            x1={xScale(tick)}
            y1={plotTop}
            x2={xScale(tick)}
            y2={plotBottom}
          />
        ))}
        {ticks.map(tick => (
          <text
            key={`tick-${mode}-${tick}`}
            className="encode-axis-tick"
            x={xScale(tick)}
            y={plotBottom + 36}
            textAnchor="middle"
          >
            {mode === 'kg' ? formatKg(tick) : `${tick}%`}
          </text>
        ))}
        <line
          className="encode-axis-line"
          x1={margin.left}
          y1={plotBottom}
          x2={margin.left + plotWidth}
          y2={plotBottom}
        />
        {dataset.countries.map(country => {
          const y = yScale(country.country)
          if (y === undefined) return null
          return (
            <text
              key={`country-label-${mode}-${country.country}`}
              className="encode-country-label"
              x={margin.left - 18}
              y={y + yScale.bandwidth() / 2}
              textAnchor="end"
              dominantBaseline="middle"
            >
              {country.country}
            </text>
          )
        })}
        {markElements}
        {valueLabels}
        {totalLabels}
        <text
          className="encode-axis-label"
          x={margin.left + plotWidth / 2}
          y={plotBottom + 96}
          textAnchor="middle"
        >
          {mode === 'kg' ? 'Kilograms per person per year' : "Percent share of each country's total"}
        </text>
      </g>
    )
  }

  const renderHeatmap = (snapshot: ChartSnapshot, ghost: boolean) => {
    if (!dataset) return null
    const countries = dataset.countries
    const categories = MEAT_CATEGORIES

    const cellWidth = 126
    const cellHeight = 42
    const startX = 292
    const startY = 170
    const totalWidth = categories.length * cellWidth
    const totalHeight = countries.length * cellHeight

    const cells: JSX.Element[] = []
    const values: JSX.Element[] = []
    let markIndex = 0

    countries.forEach((country, rowIndex) => {
      categories.forEach((category, colIndex) => {
        const kg = country.kg[category.key]
        const percent = country.percent[category.key]
        const intensity =
          snapshot.measure === 'kg'
            ? dataset.maxCategoryKg > 0
              ? kg / dataset.maxCategoryKg
              : 0
            : percent / 100
        const normalized = clamp01(intensity)
        const fill = d3.interpolateLab('#f6f8fc', getCategoryColor(category.key, snapshot))(normalized)
        const x = startX + colIndex * cellWidth
        const y = startY + rowIndex * cellHeight
        const isHovered =
          !ghost &&
          hoveredDatum?.country === country.country &&
          hoveredDatum.category === category.key
        const isColorPulse = !ghost && juicyActive && colorPulseCategory === category.key

        cells.push(
          <rect
            key={`cell-${country.country}-${category.key}`}
            data-encode-color={category.key}
            className={markClassName(category.key, isHovered, ghost, 'heatmap')}
            style={markStyle(markIndex, ghost)}
            x={x}
            y={y}
            width={cellWidth}
            height={cellHeight}
            fill={fill}
            opacity={categoryOpacity(category.key, snapshot.focusCategory, ghost)}
            stroke={isHovered ? '#0f172a' : isColorPulse ? 'rgba(0, 0, 0, 0.75)' : 'rgba(0, 0, 0, 0)'}
            strokeWidth={isHovered ? 2 : isColorPulse ? 1.8 : 1}
            filter={juicyActive && isHovered && !ghost ? 'url(#encode-hover-glow-filter)' : undefined}
            onMouseEnter={ghost ? undefined : event => handleMarkEnter(event, country.country, category.key)}
            onMouseMove={ghost ? undefined : handleMarkMove}
            onMouseLeave={ghost ? undefined : handleMarkLeave}
          />
        )

        if (!ghost) {
          values.push(
            <text
              key={`cell-label-${country.country}-${category.key}`}
              className="encode-heatmap-value"
              x={x + cellWidth / 2}
              y={y + cellHeight / 2}
              textAnchor="middle"
              dominantBaseline="middle"
              fill={getReadableTextColor(fill)}
            >
              {snapshot.measure === 'kg' ? formatKg(kg) : formatPercent(percent)}
            </text>
          )
        }
        markIndex += 1
      })
    })

    return (
      <g className={ghost ? 'encode-chart-layer is-ghost' : 'encode-chart-layer'}>
        {categories.map((category, index) => (
          <text
            key={`heatmap-col-${category.key}`}
            className="encode-heatmap-col-label"
            x={startX + index * cellWidth + cellWidth / 2}
            y={startY - 24}
            textAnchor="middle"
          >
            {category.label}
          </text>
        ))}
        {countries.map((country, index) => (
          <text
            key={`heatmap-row-${country.country}`}
            className="encode-country-label"
            x={startX - 20}
            y={startY + index * cellHeight + cellHeight / 2}
            textAnchor="end"
            dominantBaseline="middle"
          >
            {country.country}
          </text>
        ))}
        <rect
          className="encode-heatmap-frame"
          x={startX}
          y={startY}
          width={totalWidth}
          height={totalHeight}
        />
        {cells}
        {values}
      </g>
    )
  }

  const renderMultiRingDonut = (snapshot: ChartSnapshot, ghost: boolean) => {
    if (!dataset) return null
    const countries = dataset.countries
    const countryCount = countries.length

    const donutCenterX = SVG_WIDTH * 0.5
    const donutCenterY = SVG_HEIGHT * 0.52
    const outerRadius = 296
    const ringGap = 3.4
    const desiredThickness = 24
    const minInnerRadius = 54
    const requiredInner =
      outerRadius - desiredThickness * countryCount - ringGap * (countryCount - 1)
    const innerRadius = requiredInner >= minInnerRadius ? requiredInner : minInnerRadius
    const ringThickness =
      requiredInner >= minInnerRadius
        ? desiredThickness
        : Math.max(
            16,
            Math.min(
              24,
              (outerRadius - innerRadius - ringGap * (countryCount - 1)) / Math.max(1, countryCount)
            )
          )
    const labelStartAngle = -Math.PI * 0.92
    const labelEndAngle = -Math.PI * 0.08

    const pie = d3
      .pie<{ category: MeatCategoryDef; value: number }>()
      .sort(null)
      .value(item => item.value)
      .padAngle(0.013)

    const arcMarks: JSX.Element[] = []
    const countryLabelDefs: JSX.Element[] = []
    const countryRingLabels: JSX.Element[] = []

    countries.forEach((country, countryIndex) => {
      const ringOuter = outerRadius - countryIndex * (ringThickness + ringGap)
      const ringInner = ringOuter - ringThickness
      const arcGenerator = d3
        .arc<d3.PieArcDatum<{ category: MeatCategoryDef; value: number }>>()
        .innerRadius(ringInner)
        .outerRadius(ringOuter)
        .cornerRadius(2)

      const series = pie(
        MEAT_CATEGORIES.map(category => ({
          category,
          value: country.percent[category.key]
        }))
      )

      series.forEach((slice, categoryIndex) => {
        const category = slice.data.category
        const isHovered =
          !ghost &&
          hoveredDatum?.country === country.country &&
          hoveredDatum.category === category.key
        const isColorPulse = !ghost && juicyActive && colorPulseCategory === category.key
        const markIndex = countryIndex * MEAT_CATEGORIES.length + categoryIndex
        arcMarks.push(
          <path
            key={`donut-slice-${country.country}-${category.key}`}
            data-encode-color={category.key}
            className={markClassName(category.key, isHovered, ghost, 'donut')}
            style={markStyle(markIndex, ghost)}
            d={arcGenerator(slice) ?? ''}
            fill={getCategoryColor(category.key, snapshot)}
            opacity={categoryOpacity(category.key, snapshot.focusCategory, ghost)}
            stroke={isHovered ? '#0f172a' : isColorPulse ? 'rgba(0, 0, 0, 0.75)' : 'rgba(0, 0, 0, 0)'}
            strokeWidth={isHovered ? 2.2 : isColorPulse ? 1.9 : 1}
            filter={juicyActive && isHovered && !ghost ? 'url(#encode-hover-glow-filter)' : undefined}
            onMouseEnter={ghost ? undefined : event => handleMarkEnter(event, country.country, category.key)}
            onMouseMove={ghost ? undefined : handleMarkMove}
            onMouseLeave={ghost ? undefined : handleMarkLeave}
          />
        )
      })

      const labelRadius = ringInner + ringThickness * 0.55
      const labelPathId = `encode-donut-label-${ghost ? 'ghost' : 'live'}-${countryIndex}`
      const maxChars = countryIndex >= Math.floor(countryCount * 0.66) ? 4 : countryIndex >= Math.floor(countryCount * 0.33) ? 8 : 12
      const countryLabel = compactCountryLabel(country.country, maxChars)
      const labelPath =
        d3