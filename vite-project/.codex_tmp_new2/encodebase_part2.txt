  const wheelPreviewExpiryTimeoutRef = useRef<number | null>(null)
  const transitionRingFadeTimeoutRef = useRef<number | null>(null)
  const focusPulseTimeoutRef = useRef<number | null>(null)
  const colorPulseTimeoutRef = useRef<number | null>(null)
  const projectorFlashTimeoutRef = useRef<number | null>(null)
  const chartShakeTimeoutRef = useRef<number | null>(null)
  const rippleTimeoutRef = useRef<number | null>(null)
  const particleTimeoutsRef = useRef<number[]>([])
  const globalParticleTimeoutsRef = useRef<number[]>([])
  const windingClickTimeoutsRef = useRef<number[]>([])
  const previousCategoryColorsRef = useRef<Record<MeatCategoryKey, string>>({
    ...INITIAL_CATEGORY_COLORS
  })

  const categoryByKey = useMemo(() => {
    const map = new Map<MeatCategoryKey, MeatCategoryDef>()
    MEAT_CATEGORIES.forEach(category => map.set(category.key, category))
    return map
  }, [])

  const countryByName = useMemo(() => {
    const map = new Map<string, MeatCountryDatum>()
    dataset?.countries.forEach(country => map.set(country.country, country))
    return map
  }, [dataset])

  const measureLocked = representation !== 'heatmap'
  const activeMeasure: Measure = measureForRepresentation(representation, measure)
  const juicyActive = juicy && !prefersReducedMotion
  const motionSafe = !prefersReducedMotion
  const representationIndex = representationToIndex(representation)
  const sliderFillPercent = (representationIndex / (REPRESENTATION_ORDER.length - 1)) * 100
  const sliderDisplayPercent = juicyActive && motionSafe ? sliderVisualPercent : sliderFillPercent
  const activeHoverCategory = legendHoverCategory ?? markHoverCategory
  const ringRadius = 20
  const ringCircumference = Math.PI * 2 * ringRadius

  const chartSubtitle =
    activeMeasure === 'kg'
      ? 'Kilograms per person per year'
      : "Share of each country's total (%)"

  const currentSnapshot = useMemo<ChartSnapshot>(
    () => ({
      representation,
      measure: activeMeasure,
      focusCategory,
      colors: { ...categoryColors }
    }),
    [representation, activeMeasure, focusCategory, categoryColors]
  )

  const previewSnapshot = useMemo<ChartSnapshot | null>(() => {
    if (!previewRepresentation) return null
    if (previewRepresentation === representation) return null
    return {
      representation: previewRepresentation,
      measure: measureForRepresentation(previewRepresentation, activeMeasure),
      focusCategory,
      colors: { ...categoryColors }
    }
  }, [activeMeasure, categoryColors, focusCategory, previewRepresentation, representation])

  const previewActive = Boolean(
    juicyActive &&
      !isTransitioning &&
      previewMode &&
      previewRepresentation &&
      previewRepresentation !== representation &&
      previewSnapshot
  )

  const getCategoryColor = (category: MeatCategoryKey, snapshot?: ChartSnapshot): string => {
    if (snapshot) return snapshot.colors[category] ?? categoryColors[category]
    return categoryColors[category]
  }

  const getReadableTextColor = (background: string): '#ffffff' | '#0b1220' => {
    const parsed = d3.color(background)
    if (!parsed) return '#0b1220'
    const rgb = parsed.rgb()
    const [r, g, b] = [rgb.r, rgb.g, rgb.b].map(value => {
      const normalized = value / 255
      return normalized <= 0.03928
        ? normalized / 12.92
        : ((normalized + 0.055) / 1.055) ** 2.4
    })
    const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b
    return luminance < 0.45 ? '#ffffff' : '#0b1220'
  }

  const tooltipTarget = useMemo<TooltipDatum | null>(() => {
    if (!dataset || !hoveredDatum) return null
    const country = countryByName.get(hoveredDatum.country)
    if (!country) return null

    const kg = country.kg[hoveredDatum.category]
    const percent = country.percent[hoveredDatum.category]
    let encoded = percent

    if (representation === 'stacked-bar') {
      encoded = dataset.maxTotalKg > 0 ? (kg / dataset.maxTotalKg) * 100 : 0
    } else if (representation === 'heatmap') {
      const intensity =
        activeMeasure === 'kg'
          ? dataset.maxCategoryKg > 0
            ? kg / dataset.maxCategoryKg
            : 0
          : percent / 100
      encoded = intensity * 100
    }

    return {
      ...hoveredDatum,
      kg,
      percent,
      encoded: clamp01(encoded / 100) * 100
    }
  }, [activeMeasure, countryByName, dataset, hoveredDatum, representation])

  const tooltipSignature = tooltipTarget
    ? `${tooltipTarget.country}|${tooltipTarget.category}|${tooltipTarget.kg.toFixed(4)}|${tooltipTarget.percent.toFixed(4)}|${tooltipTarget.encoded.toFixed(4)}`
    : 'none'

  const categoryOpacity = (
    category: MeatCategoryKey,
    snapshotFocus: FocusCategory,
    ghost: boolean
  ): number => {
    const focusOpacity =
      snapshotFocus !== 'All'
        ? snapshotFocus === category
          ? 1
          : 0.3
        : activeHoverCategory && activeHoverCategory !== category
          ? 0.45
          : 1
    return ghost ? focusOpacity * 0.56 : focusOpacity
  }

  const markClassName = (
    category: MeatCategoryKey,
    isHovered: boolean,
    ghost: boolean,
    markType: 'bar' | 'heatmap' | 'donut'
  ): string => {
    const classes = ['encode-mark', `encode-mark-${markType}`]
    if (ghost) classes.push('is-ghost-mark')
    if (isHovered) classes.push(juicyActive ? 'is-hovered-juicy' : 'is-hovered-basic')
    if (!ghost && juicyActive && focusPulseCategory === category) classes.push('is-focus-pulse')
    if (!ghost && juicyActive && motionSafe && isTransitioning) classes.push('is-enter-mark')
    if (!ghost && juicyActive && colorPulseCategory === category) {
      classes.push('is-color-pulse', `is-color-pulse-${colorPulseId % 2}`)
    }
    return classes.join(' ')
  }

  const markStyle = (markIndex: number, ghost: boolean): CSSProperties | undefined => {
    if (ghost) return undefined
    if (!(juicyActive && motionSafe && isTransitioning)) return undefined
    return {
      animationDelay: `${Math.min(240, markIndex * 11)}ms`
    }
  }

  const clearTimeoutRef = (ref: React.MutableRefObject<number | null>) => {
    if (ref.current !== null) {
      window.clearTimeout(ref.current)
      ref.current = null
    }
  }

  const clearTimeoutList = (timeouts: number[]) => {
    timeouts.forEach(timeout => window.clearTimeout(timeout))
    timeouts.length = 0
  }

  const animateSliderVisualTo = useCallback((nextPercent: number, durationMs: number) => {
    if (sliderVisualRafRef.current !== null) {
      window.cancelAnimationFrame(sliderVisualRafRef.current)
      sliderVisualRafRef.current = null
    }
    const startPercent = sliderVisualPercentRef.current
    const startTime = performance.now()
    const step = (timestamp: number) => {
      const progress = clamp01((timestamp - startTime) / durationMs)
      const eased = d3.easeCubicOut(progress)
      const value = startPercent + (nextPercent - startPercent) * eased
      sliderVisualPercentRef.current = value
      setSliderVisualPercent(value)
      if (progress < 1) {
        sliderVisualRafRef.current = window.requestAnimationFrame(step)
      } else {
        sliderVisualRafRef.current = null
      }
    }
    sliderVisualRafRef.current = window.requestAnimationFrame(step)
  }, [])

  const emitGlobalParticles = useCallback(
    (
      clientX: number,
      clientY: number,
      count: number,
      variant: ParticleState['variant'],
      color?: string,
      sizeMultiplier = 1
    ) => {
      if (!(juicyActive && motionSafe)) return
      const particleLimit = isTransitioning ? TRANSITION_PARTICLE_CAP : PARTICLE_MAX_COUNT
      const clampedCount = Math.max(1, Math.min(isTransitioning ? 24 : 36, count))
      const now = performance.now()
      const palette = color
        ? [color, '#ffffff', '#ffd166']
        : ['#2f63d1', '#4ecdc4', '#ffd166', '#ff8fab', '#ffffff']
      const created = Array.from({ length: clampedCount }, (_, index) => {
        const angle = (Math.PI * 2 * index) / clampedCount + Math.random() * 0.8
        const distance =
          variant === 'burst'
            ? 24 + Math.random() * 38
            : variant === 'trail'
              ? 8 + Math.random() * 14
              : 14 + Math.random() * 24
        return {
          id: now + index + Math.random(),
          x: clientX,
          y: clientY,
          size:
            variant === 'trail'
              ? 1.8 + Math.random() * 1.8
              : variant === 'spark'
                ? 2.2 + Math.random() * 2.2
                : (2.8 + Math.random() * 3.2) * Math.max(0.8, sizeMultiplier),
          dx: Math.cos(angle) * distance,
          dy: Math.sin(angle) * distance - (variant === 'trail' ? 1 : 4),
          color: palette[Math.floor(Math.random() * palette.length)],
          variant
        } as ParticleState
      })

      setGlobalParticles(previous => [...previous, ...created].slice(-particleLimit))

      const ids = new Set(created.map(particle => particle.id))
      const timeout = window.setTimeout(() => {
        setGlobalParticles(previous => previous.filter(particle => !ids.has(particle.id)))
        globalParticleTimeoutsRef.current = globalParticleTimeoutsRef.current.filter(
          item => item !== timeout
        )
      }, PARTICLE_LIFETIME_MS)
      globalParticleTimeoutsRef.current.push(timeout)
    },
    [isTransitioning, juicyActive, motionSafe]
  )

  const scheduleWindingClicks = useCallback(() => {
    if (!(juicyActive && motionSafe)) return
    const now = performance.now()
    if (now - windingSoundTimestampRef.current < 360) return
    windingSoundTimestampRef.current = now
    clearTimeoutList(windingClickTimeoutsRef.current)