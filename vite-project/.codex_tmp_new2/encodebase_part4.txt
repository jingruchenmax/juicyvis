        !isTransitioning
      ) {
        if (previewMode !== 'wheel' || !wheelPendingTarget) {
          setWheelPendingTarget({ representation: nextRepresentation, direction })
          setPreviewRepresentation(nextRepresentation)
          setPreviewMode('wheel')
          restartWheelPreviewExpiry()
          const now = performance.now()
          if (now - previewSoundTimestampRef.current > 220) {
            previewSoundTimestampRef.current = now
            playPreviewCueSound()
          }
          return
        }

        if (wheelPendingTarget.direction !== direction) {
          setWheelPendingTarget({ representation: nextRepresentation, direction })
          setPreviewRepresentation(nextRepresentation)
          restartWheelPreviewExpiry()
          return
        }

        const pending = wheelPendingTarget
        clearWheelPreviewStage()
        playClickSound()
        clearTimeoutRef(projectorFlashTimeoutRef)
        setProjectorFlashActive(true)
        projectorFlashTimeoutRef.current = window.setTimeout(() => {
          setProjectorFlashActive(false)
          switchRepresentation(pending.representation, pending.direction, 'wheel')
        }, PROJECTOR_FLASH_MS)
        return
      }
      switchRepresentation(nextRepresentation, direction, origin)
    },
    [
      clearWheelPreviewStage,
      isTransitioning,
      juicyActive,
      motionSafe,
      previewMode,
      representation,
      restartWheelPreviewExpiry,
      switchRepresentation,
      wheelPendingTarget
    ]
  )

  const handleRepresentationSlider = (index: number) => {
    if (previewMode === 'wheel') return
    const nextRepresentation = indexToRepresentation(index)
    const nextIndex = representationToIndex(nextRepresentation)
    const direction = directionBetweenIndexes(representationIndex, nextIndex)
    switchRepresentation(nextRepresentation, direction, 'slider')
  }

  const handleRepresentationTickEnter = (nextRepresentation: Representation) => {
    if (!(juicyActive && motionSafe)) return
    if (isTransitioning) return
    if (nextRepresentation === representation) return
    if (previewMode === 'wheel') return
    setPreviewRepresentation(nextRepresentation)
    setPreviewMode('hover')
    const now = performance.now()
    if (now - previewSoundTimestampRef.current > 180) {
      previewSoundTimestampRef.current = now
      playHoverSound()
    }
  }

  const handleRepresentationTickLeave = () => {
    if (previewMode !== 'hover') return
    setPreviewRepresentation(null)
    setPreviewMode(null)
  }

  const handleFocusCategoryChange = (
    nextCategory: FocusCategory,
    sourceElement?: HTMLElement | null
  ) => {
    if (nextCategory === focusCategory) return
    setFocusCategory(nextCategory)
    runFocusFeedback(nextCategory, sourceElement)
    if (juicyActive && motionSafe && nextCategory !== 'All') {
      const now = performance.now()
      if (now - representationSoundTimestampRef.current > 130) {
        representationSoundTimestampRef.current = now
        playClickSound()
      }
    }
  }

  const handleMeasureChange = (nextMeasure: Measure) => {
    if (measureLocked) return
    if (nextMeasure === measure) return
    setMeasure(nextMeasure)
    setTransitionKey(key => key + 1)
  }

  const handleMarkEnter = (
    event: MouseEvent<SVGElement>,
    country: string,
    category: MeatCategoryKey
  ) => {
    setMarkHoverCategory(category)
    setHoveredDatum({
      country,
      category,
      clientX: event.clientX,
      clientY: event.clientY
    })

    if (!(juicyActive && motionSafe)) return

    const now = performance.now()
    if (now - hoverSoundTimestampRef.current > 130) {
      hoverSoundTimestampRef.current = now
      playHoverSound()
    }
    if (isTransitioning) return
    if (now - sparkleTimestampRef.current > 90) {
      sparkleTimestampRef.current = now
      const color = categoryByKey.get(category)?.color
      emitParticlesFromClient(event.clientX, event.clientY, 8, 'spark', color)
    }
  }

  const handleMarkMove = (event: MouseEvent<SVGElement>) => {
    setHoveredDatum(previous =>
      previous
        ? {
            ...previous,
            clientX: event.clientX,
            clientY: event.clientY
          }
        : previous
    )
  }

  const handleMarkLeave = () => {
    setMarkHoverCategory(null)
    setHoveredDatum(null)
  }

  const handleStageMouseMove = (event: MouseEvent<HTMLDivElement>) => {
    if (hoveredDatum) {
      setHoveredDatum(previous =>
        previous
          ? {
              ...previous,
              clientX: event.clientX,
              clientY: event.clientY
            }
          : previous
      )
    }

    const stage = chartStageRef.current
    if (!stage) return
    const bounds = stage.getBoundingClientRect()
    const x = event.clientX - bounds.left
    const y = event.clientY - bounds.top

    setCursorPosition({ x, y })
    setIsCursorInsideStage(true)
  }

  const handleChartMouseLeave = () => {
    setMarkHoverCategory(null)
    setHoveredDatum(null)
    setIsCursorInsideStage(false)
    if (previewMode === 'hover') {
      setPreviewRepresentation(null)
      setPreviewMode(null)
    }
    wheelAccumulatorRef.current = 0
  }

  const handleCategoryColorChange = (
    category: MeatCategoryKey,
    color: string,
    sourceElement?: HTMLElement | null
  ) => {
    if (sourceElement instanceof HTMLInputElement) {
      colorChangeAnchorRectRef.current = sourceElement.getBoundingClientRect()
    }
    setCategoryColors(previous => ({ ...previous, [category]: color }))
  }

  const handleColorSwatchClick = (
    _event: MouseEvent<HTMLButtonElement>,
    category: MeatCategoryKey
  ) => {
    const inputElement = colorInputRefs.current[category]
    if (!inputElement) return
    colorChangeAnchorRectRef.current = inputElement.getBoundingClientRect()
    inputElement.click()
  }

  const handleColorInputFocus = (
    event: FocusEvent<HTMLInputElement>,
    _category: MeatCategoryKey
  ) => {
    colorChangeAnchorRectRef.current = event.currentTarget.getBoundingClientRect()
  }

  useEffect(() => {
    tooltipDisplayRef.current = tooltipDisplay
  }, [tooltipDisplay])

  useEffect(() => {
    const media = window.matchMedia('(prefers-reduced-motion: reduce)')
    const update = () => {
      setPrefersReducedMotion(media.matches)
    }

    update()
    if (typeof media.addEventListener === 'function') {
      media.addEventListener('change', update)
      return () => media.removeEventListener('change', update)
    }
    media.addListener(update)
    return () => media.removeListener(update)
  }, [])

  useEffect(() => {
    if (juicyActive) return
    setFocusPulseCategory(null)
    setColorPulseCategory(null)
    setRipple(null)
    setParticles([])
    setGlobalParticles([])
    setChartShakeActive(false)
    setIsCursorInsideStage(false)
    setPreviewRepresentation(null)
    setPreviewMode(null)
    setWheelPendingTarget(null)
    setProjectorFlashActive(false)
    setTransitionRingVisible(false)
    colorChangeAnchorRectRef.current = null
  }, [juicyActive])

  useEffect(() => {
    sliderVisualPercentRef.current = sliderVisualPercent
  }, [sliderVisualPercent])

  useEffect(() => {
    if (!(juicyActive && motionSafe)) {
      sliderVisualPercentRef.current = sliderFillPercent
      setSliderVisualPercent(sliderFillPercent)
      return
    }
    animateSliderVisualTo(sliderFillPercent, SLIDER_VISUAL_DURATION_MS)
  }, [animateSliderVisualTo, juicyActive, motionSafe, sliderFillPercent])

  useEffect(() => {
    if (!(juicyActive && motionSafe)) return
    const handlePointerMove = (event: PointerEvent) => {
      lastPointerClientRef.current = { x: event.clientX, y: event.clientY }
    }